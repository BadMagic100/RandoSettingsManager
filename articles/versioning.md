# Versioning Best Practices

This article discusses the dos and don'ts when implementing a versioning policy for backwards compatibility.

## Basics

Version checking is intended as an early validation mechanism for settings codes to flag any potential hash mismatches
before they can happen. Any change to the semantics of your settings, any logic change, or anything else which could
impact the randomizer hash should also affect the version provided by your versioning policy. Version checking policies
are used on temporary profiles and quick share, but are not used for long-lived profiles. The expection is that the
structure of settings rarely changes in a way that is truly breaking (for example, changing the type of a field), so
settings profiles can continue to be reused for roughly the same experience across versions.

The most important thing to do when creating a versioning policy is to not make one that's too permissive. Doing so can
result in difficult to diagnose hash mismatches. When in doubt, a stricter policy, such as [`StrictModVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.StrictModVersioningPolicy.yml)
is preferred. In contrast, the most permissive policy available ([`NoVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.NoVersioningPolicy.yml))
should almost never be used unless you never make any hash-impacting changes (however, if this is the case, it's also
likely that you just don't need to send settings at all and leave it to players to locally configure based on their 
own preferences).

Generally, implementing a less strict policy is only for the convenience of the players, and usually follows the rule
of diminishing returns - as you add more permissiveness it becomes exponentially harder to implement (and especially,
to implement correctly). If you're more interested in developer convenience, then [`StrictModVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.StrictModVersioningPolicy.yml)
is usually the correct choice for you.

## Choosing a Versioning Policy

Aside from the behavior discussed above, well-implemented versioning policies should have the following 2 properties:
* Versioning policies should allow settings from another version if an only if, based on the content of the version
  alone, it is guaranteed that any possible settings generated by the sender will yield the same hash when applied to
  the receiver.
* Versioning policies should be symmetric; they will both succeed or fail regardless of which build is the sender.

This means that choosing/implementing a policy correctly is very important! In particular, it can be the case that 
changing policies can break the symmetry requirement. This section will guide you through how to pick a policy with
these constraints in mind.

### Selecting an Existing Policy

Before attempting to implement a custom versioning policy, consider whether any of the policies included in RSM will
work for your use case. These policies fulfill all the requirements discussed previously in this documentation and
cover many common needs you may encounter.

* [`StrictModVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.StrictModVersioningPolicy.yml) -
  as discussed many times, this policy is usually the safest policy when in doubt. It will "break" with every release
  of your connection, assuming that you remember to update the mod version.
* [`EqualityVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.EqualityVersioningPolicy-1.yml) -
  This policy allows you to arbitrarily version your settings (separately from your mod if desired) and use a custom
  comparison (for example, [`SemVerComparator`](~/api/RandoSettingsManager.SettingsManagement.Versioning.Comparators.SemVerComparator.yml)),
  and checks equality based on the provided values.
* [`ContentHashVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.ContentHashVersioningPolicy.yml) -
  This policy performs version checking based on the SHA1 hash of a given (usually embedded) resource file.
* [`CompoundVersioningPolicy`](~/api/RandoSettingsManager.SettingsManagement.Versioning.CompoundVersioningPolicy.yml) -
  This policy combines the results of up to 8 different versioning policies.
  
Aside from `StrictModVersioningPolicy`, using a `CompoundVersioningPolicy` which contains an `EqualityVersioningPolicy`
with a `SemVerComparator`, and a `ContentHashVersioningPolicy` for each of your logic files is fairly safe, assuming
that you bump your major or minor version whenever there is a significant change to your settings (This is BadMagic's 
preference in most cases as it allows players, including the developer, to play on different patch versions which is
useful for development).

### Implementing Your Own Policies

The requirements of a well-implemented policy have already been discussed above. The code for the bundled policies is
under MIT license and can be used as reference. Some more complex examples are also available in the 
[cookbook section](~/articles/cookbook.md).
  
### Switching Policies

As discussed above, ideally, you just won't ever switch policies. However this is not really a reasonable expectation. 
If you find yourself needing to switch policies, consider changing to a policy with a different underlying type if
possible/helpful. This guarantees that symmetry will be maintained, since the policy will always fail to deserialize
the provided version on either side. Conversely, changing policies without changing the underlying type is quite hard
to do safely depending on the manner in which semantics change. Be mindful of this type of swap; in the worst case you
may just need to inform users about the change so they're not caught off-guard by hash mismatches. Note that changing
to or from NoVersioningPolicy will almost always break symmetry, as it sends `null` and allows any incoming value.
This is another good reason to avoid it if at all possible.

